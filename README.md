[![Go Report Card](https://goreportcard.com/badge/github.com/KimMachineGun/mockc)](https://goreportcard.com/report/github.com/KimMachineGun/mockc)
# Mockc: Complie-time mock generator for Go
Mockc is a completely type-safe compile-time mock generator for Go. It simply parses your mock generators and creates mocks. You can use it just by writing the mock generators with `mockc.Implements()`.

## Features
- Tools
  - [x] Generate mocks with mock generators
  - [ ] Generate mocks with command line flags
- Generated Mocks
  - [x] Method params and results
  - [x] Method body injection
  - [x] Method call history

## Installation
```
go get github.com/KimMachineGun/mockc/cmd/mockc
```

## Look and Feel
[example](https://github.com/KimMachineGun/mockc/tree/master/example)
### 1. Create mock generator
#### target interface:
```go
package ex

type Cache interface {
	Get(key string) (val interface{}, err error)
	Set(key string, val interface{}) (err error)
	Del(key string) (err error)
}
```
#### mock generator:
```go
//+build mockc

package ex

import (
	"github.com/KimMachineGun/mockc"
)

func MockcCache() {
	mockc.Implements(Cache(nil))
}
```
### 2. Generate mocks
#### command:
```sh
mockc [<packages-pattern>]
```
#### generated mock:	
```go
// Code generated by Mockc. DO NOT EDIT.
// repo: https://github.com/KimMachineGun/mockc

//go:generate mockc
// +build !mockc

package ex

import (
	"sync"
)

type MockcCache struct {
	// method: Del
	_Del struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				key string
			}
			Results struct {
				err error
			}
		}
		// params
		Params struct {
			key string
		}
		// results
		Results struct {
			err error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string) error
	}
	// method: Get
	_Get struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				key string
			}
			Results struct {
				val interface{}
				err error
			}
		}
		// params
		Params struct {
			key string
		}
		// results
		Results struct {
			val interface{}
			err error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string) (interface{}, error)
	}
	// method: Set
	_Set struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				key string
				val interface{}
			}
			Results struct {
				err error
			}
		}
		// params
		Params struct {
			key string
			val interface{}
		}
		// results
		Results struct {
			err error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string, interface{}) error
	}
}

func (recv *MockcCache) Del(p0 string) error {
	recv._Del.mu.Lock()
	defer recv._Del.mu.Unlock()
	// basics
	recv._Del.Called = true
	recv._Del.CallCount++
	// params
	recv._Del.Params.key = p0
	// body
	if recv._Del.Body != nil {
		recv._Del.Results.err = recv._Del.Body(p0)
	}
	// call history
	recv._Del.History = append(recv._Del.History, struct {
		Params struct {
			key string
		}
		Results struct {
			err error
		}
	}{
		Params:  recv._Del.Params,
		Results: recv._Del.Results,
	})
	// results
	return recv._Del.Results.err
}

func (recv *MockcCache) Get(p0 string) (interface{}, error) {
	recv._Get.mu.Lock()
	defer recv._Get.mu.Unlock()
	// basics
	recv._Get.Called = true
	recv._Get.CallCount++
	// params
	recv._Get.Params.key = p0
	// body
	if recv._Get.Body != nil {
		recv._Get.Results.val, recv._Get.Results.err = recv._Get.Body(p0)
	}
	// call history
	recv._Get.History = append(recv._Get.History, struct {
		Params struct {
			key string
		}
		Results struct {
			val interface{}
			err error
		}
	}{
		Params:  recv._Get.Params,
		Results: recv._Get.Results,
	})
	// results
	return recv._Get.Results.val, recv._Get.Results.err
}

func (recv *MockcCache) Set(p0 string, p1 interface{}) error {
	recv._Set.mu.Lock()
	defer recv._Set.mu.Unlock()
	// basics
	recv._Set.Called = true
	recv._Set.CallCount++
	// params
	recv._Set.Params.key = p0
	recv._Set.Params.val = p1
	// body
	if recv._Set.Body != nil {
		recv._Set.Results.err = recv._Set.Body(p0, p1)
	}
	// call history
	recv._Set.History = append(recv._Set.History, struct {
		Params struct {
			key string
			val interface{}
		}
		Results struct {
			err error
		}
	}{
		Params:  recv._Set.Params,
		Results: recv._Set.Results,
	})
	// results
	return recv._Set.Results.err
}
```
### 4. Feel free to use the generated mock
#### test code:
```go
package ex

import (
	"errors"
	"testing"
)

func HasKey(c Cache, key string) (bool, error) {
	val, err := c.Get(key)
	if err != nil {
		return false, err
	}

	return val != nil, nil
}

func TestHasKey(t *testing.T) {
	m := &MockcCache{}

	m._Get.Results.val = struct{}{}

	key := "key"
	expected := true
	actual, err := HasKey(m, key)

	if actual != expected {
		t.Errorf("result: expected(%v) != actual(%v)", expected, actual)
	}
	if err != nil {
		t.Errorf("err: %v", err)
	}
	if m._Get.Params.key != key {
		t.Errorf("expected(%v) != actual(%v)", key, m._Get.Params.key)
	}
}

func TestHasKey_WithMethodBodyInjection(t *testing.T) {
	m := &MockcCache{}
	m._Get.Body = func(key string) (interface{}, error) {
		if key == "key" {
			return nil, errors.New("err")
		}
		return nil, nil
	}

	key := "key"
	expected := false
	actual, err := HasKey(m, key)

	if expected != actual {
		t.Errorf("result: expected(%v) != actual(%v)", expected, actual)
	}
	if err == nil {
		t.Errorf("err: %v", err)
	}
	if key != m._Get.Params.key {
		t.Errorf("param key: expected(%v) != actual(%v)", key, m._Get.Params.key)
	}
}

func TestHasKey_WithHistory(t *testing.T) {
	m := &MockcCache{}

	table := []struct {
		key string
		val interface{}

		expected bool
		err      error
	}{
		{
			key: "key1",
			val: struct{}{},

			expected: true,
			err:      nil,
		},
		{

			key: "key2",
			val: nil,

			expected: false,
			err:      errors.New("err"),
		},
	}

	for _, t := range table {
		m._Get.Results.val = t.val
		m._Get.Results.err = t.err

		HasKey(m, t.key)
	}

	for idx, h := range m._Get.History {
		if expected, actual := table[idx].expected, h.Results.val != nil; expected != actual {
			t.Errorf("table[%v] result : expected(%v) != actual(%v)", idx, expected, actual)
		}
		if expected, actual := table[idx].err, h.Results.err; expected != actual {
			t.Errorf("table[%v] err : expected(%v) != actual(%v)", idx, expected, actual)
		}
		if expected, actual := table[idx].key, h.Params.key; expected != actual {
			t.Errorf("table[%v] param key: expected(%v) != actual(%v)", idx, expected, actual)
		}
	}
}
```

## Inspired by üôè
- [github.com/google/wire](https://github.com/google/wire)
- [github.com/sasha-s/goimpl](https://github.com/sasha-s/goimpl)
- [github.com/vektra/mockery](https://github.com/vektra/mockery)
