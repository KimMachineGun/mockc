# Mockc: Complie-time mock generator for Go
Mockc is a compile-time mock generator for Go. It simply parses your mock generators and creates mocks. Mockc is completely type safe. You can use it just by writing a mock generator with `mockc.Implements()` and `mockc.SetMode()`.

> This is beta release. This might have some bugs. Please submit your [issue](https://github.com/KimMachineGun/mockc/issues/new).

## Features
- [x] Mock generation with `mockc.Implements()`
  - [x] Method params and results
  - [x] Method body injection
  - [x] Method call history
- [ ] Mock mode setting with `mockc.SetMode()`

## Installation
```
go get github.com/KimMachineGun/mockc/cmd/mockc
```

## Look and Feel
### 1. Create mock generator
#### interface example:
```go
package ex

type Cache interface {
	Get(key string) (val interface{}, err error)
	Set(key string, val interface{}) (err error)
	Del(key string) (err error)
}
```
#### mock generator example:
```go
//+build mockc
package ex
import (
	"github.com/KimMachineGun/mockc"
)
func MockcCache() {
	mockc.Implements(Cache(nil))
}
```
### 2. Generate mocks
#### command example:
```sh
mockc [<packages-pattern>]
```
#### generated file example:	
```go
// Code generated by Mockc. DO NOT EDIT.
// repo: https://github.com/KimMachineGun/mockc

//go:generate mockc
// +build !mockc

package ex

type MockcCache struct {
	mockcs struct {
		// method: Set
		Set struct {
			// basics
			Called    bool
			CallCount int
			// call history
			History []struct {
				Params struct {
					key string
					val interface{}
				}
				Results struct {
					err error
				}
			}
			// last params
			Params struct {
				key string
				val interface{}
			}
			// last results
			Results struct {
				err error
			}
			// if Body is not nil, it is called in the middle of the method.
			Body func(string, interface{}) error
		}
		// method: Del
		Del struct {
			// basics
			Called    bool
			CallCount int
			// call history
			History []struct {
				Params struct {
					key string
				}
				Results struct {
					err error
				}
			}
			// last params
			Params struct {
				key string
			}
			// last results
			Results struct {
				err error
			}
			// if Body is not nil, it is called in the middle of the method.
			Body func(string) error
		}
		// method: Get
		Get struct {
			// basics
			Called    bool
			CallCount int
			// call history
			History []struct {
				Params struct {
					key string
				}
				Results struct {
					val interface{}
					err error
				}
			}
			// last params
			Params struct {
				key string
			}
			// last results
			Results struct {
				val interface{}
				err error
			}
			// if Body is not nil, it is called in the middle of the method.
			Body func(string) (interface{}, error)
		}
	}
}

func (recv *MockcCache) Set(p0 string, p1 interface{}) error {
	// basics
	recv.mockcs.Set.Called = true
	recv.mockcs.Set.CallCount++
	// params
	recv.mockcs.Set.Params.key = p0
	recv.mockcs.Set.Params.val = p1
	// body
	if recv.mockcs.Set.Body != nil {
		recv.mockcs.Set.Results.err = recv.mockcs.Set.Body(p0, p1)
	}
	// call history
	recv.mockcs.Set.History = append(recv.mockcs.Set.History, struct {
		Params struct {
			key string
			val interface{}
		}
		Results struct {
			err error
		}
	}{
		Params:  recv.mockcs.Set.Params,
		Results: recv.mockcs.Set.Results,
	})
	// results
	return recv.mockcs.Set.Results.err
}

func (recv *MockcCache) Del(p0 string) error {
	// basics
	recv.mockcs.Del.Called = true
	recv.mockcs.Del.CallCount++
	// params
	recv.mockcs.Del.Params.key = p0
	// body
	if recv.mockcs.Del.Body != nil {
		recv.mockcs.Del.Results.err = recv.mockcs.Del.Body(p0)
	}
	// call history
	recv.mockcs.Del.History = append(recv.mockcs.Del.History, struct {
		Params struct {
			key string
		}
		Results struct {
			err error
		}
	}{
		Params:  recv.mockcs.Del.Params,
		Results: recv.mockcs.Del.Results,
	})
	// results
	return recv.mockcs.Del.Results.err
}

func (recv *MockcCache) Get(p0 string) (interface{}, error) {
	// basics
	recv.mockcs.Get.Called = true
	recv.mockcs.Get.CallCount++
	// params
	recv.mockcs.Get.Params.key = p0
	// body
	if recv.mockcs.Get.Body != nil {
		recv.mockcs.Get.Results.val, recv.mockcs.Get.Results.err = recv.mockcs.Get.Body(p0)
	}
	// call history
	recv.mockcs.Get.History = append(recv.mockcs.Get.History, struct {
		Params struct {
			key string
		}
		Results struct {
			val interface{}
			err error
		}
	}{
		Params:  recv.mockcs.Get.Params,
		Results: recv.mockcs.Get.Results,
	})
	// results
	return recv.mockcs.Get.Results.val, recv.mockcs.Get.Results.err
}
```
### 4. Feel free to use the generated mock
Please add `//+build !mockc` build tag to the file using the generated mocks.
```go
// +build !mockc

package ex

import (
	"errors"
	"testing"
)

func HasKey(c Cache, key string) (bool, error) {
	val, err := c.Get(key)
	if err != nil {
		return false, err
	}

	return val != nil, nil
}

func TestHasKey(t *testing.T) {
	m := &MockcCache{}

	m.mockcs.Get.Results.val = struct{}{}

	key := "key"
	expected := true
	actual, err := HasKey(m, key)

	if actual != expected {
		t.Errorf("result: expected(%v) != actual(%v)", expected, actual)
	}
	if err != nil {
		t.Errorf("err: %v", err)
	}
	if m.mockcs.Get.Params.key != key {
		t.Errorf("expected(%v) != actual(%v)", key, m.mockcs.Get.Params.key)
	}
}

func TestHasKey_WithMethodBodyInjection(t *testing.T) {
	m := &MockcCache{}
	m.mockcs.Get.Body = func(key string) (interface{}, error) {
		if key == "key" {
			return nil, errors.New("err")
		}
		return nil, nil
	}

	key := "key"
	expected := false
	actual, err := HasKey(m, key)

	if expected != actual {
		t.Errorf("result: expected(%v) != actual(%v)", expected, actual)
	}
	if err == nil {
		t.Errorf("err: %v", err)
	}
	if key != m.mockcs.Get.Params.key {
		t.Errorf("param key: expected(%v) != actual(%v)", key, m.mockcs.Get.Params.key)
	}
}

func TestHasKey_WithHistory(t *testing.T) {
	m := &MockcCache{}

	table := []struct {
		key string
		val interface{}

		expected bool
		err      error
	}{
		{
			key: "key1",
			val: struct{}{},

			expected: true,
			err:      nil,
		},
		{

			key: "key2",
			val: nil,

			expected: false,
			err:      errors.New("err"),
		},
	}

	for _, t := range table {
		m.mockcs.Get.Results.val = t.val
		m.mockcs.Get.Results.err = t.err

		HasKey(m, t.key)
	}

	for idx, h := range m.mockcs.Get.History {
		if expected, actual := table[idx].expected, h.Results.val != nil; expected != actual {
			t.Errorf("table[%v] result : expected(%v) != actual(%v)", idx, expected, actual)
		}
		if expected, actual := table[idx].err, h.Results.err; expected != actual {
			t.Errorf("table[%v] err : expected(%v) != actual(%v)", idx, expected, actual)
		}
		if expected, actual := table[idx].key, h.Params.key; expected != actual {
			t.Errorf("table[%v] param key: expected(%v) != actual(%v)", idx, expected, actual)
		}
	}
}
```

## Inspired by üôè
- [github.com/google/wire](https://github.com/google/wire)
- [github.com/sasha-s/goimpl](https://github.com/sasha-s/goimpl)
- [github.com/vektra/mockery](https://github.com/vektra/mockery)
