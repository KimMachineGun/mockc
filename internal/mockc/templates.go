package mockc

import (
	"fmt"
	"strings"
	"text/template"
)

const (
	tmplString = `// Code generated by Mockc. DO NOT EDIT.
// repo: https://github.com/KimMachineGun/mockc

//go:generate {{ .GoGenerate }}
// +build !mockc

package {{ .PackageName }}

import (
	"sync"
{{- range $path, $name := .Imports }}
	{{ $name }} "{{ $path }}"
{{- end }}
)
{{ range $mock := .Mocks }}
type {{ $mock.Name }} struct {
{{- range .Methods }}
	// method: {{ .Name }}
	{{ .FieldName }} struct {
		mu sync.Mutex
		// basics
		Called bool
		CallCount int
	{{- if or (len .Params) (len .Results) }}
		// call history
		History []struct {
		{{- if len .Params }}
			Params struct {
			{{- range .Params }}
				{{ .String }}
			{{- end }}
			}
		{{- end }}
		{{- if len .Results}}
			Results struct {
			{{- range .Results }}
				{{ .String }}
			{{- end }}
			}
		{{- end }}
		}
	{{- end }}
	{{- if .Params }}
		// params
		Params struct {
		{{- range .Params }}
			{{ .String }}
		{{- end }}
		}
	{{- end }}
	{{- if len .Results}}
		// results
		Results struct {
		{{- range .Results }}
			{{ .String }}
		{{- end }}
		}
	{{- end }}
		// if it is not nil, it'll be called in the middle of the method.
		Body func({{ range $idx, $val := .Params }}{{ if $idx }}, {{ end }}{{ $val.ParamType }}{{ end }}) {{ if len .Results | lt 1 }}({{ end }}{{ range $idx, $val := .Results }}{{ if $idx }}, {{ end }}{{ $val.ResultType }}{{ end }}{{ if len .Results | lt 1 }}){{ end }}
	}
{{- end }}
}
{{ if $mock.HasConstructor }}
func New{{ $mock.Name }}(
	v ...interface{
	{{- range $method := $mock.Methods }}
		{{ $method.Signature }}
	{{- end }}
	},
) *{{ $mock.Name }} {
	m := &{{ $mock.Name }}{}
	if len(v) > 0 {
	{{- range $method := $mock.Methods }}
		m.{{ $method.FieldName }}.Body = v[0].{{ $method.Name }}
	{{- end }}
	}
	return m
}
{{ end }}
{{ range $method := $mock.Methods }}
func (recv *{{ $mock.Name }}) {{ $method.Signature }} {
	recv.{{ $method.FieldName }}.mu.Lock()
	defer recv.{{ $method.FieldName }}.mu.Unlock()
	// basics
	recv.{{ $method.FieldName }}.Called = true
	recv.{{ $method.FieldName }}.CallCount++
{{- if len .Params }}
	// params
	{{- range $param := $method.Params }}
	recv.{{ $method.FieldName }}.Params.{{ $param.Name }} = {{ $param.ParamName }}
	{{- end }}
{{- end }}
	// body
	if recv.{{ $method.FieldName }}.Body != nil {
		{{ if len .Results }}{{ range $idx, $val := .Results }}{{ if $idx }}, {{ end }}recv.{{ $method.FieldName }}.Results.{{ $val.Name }}{{ end }} = {{ end }}recv.{{ $method.FieldName }}.Body({{ range $idx, $val := .Params }}{{ if $idx }}, {{ end }}{{ $val.ArgString }}{{ end }})
	}
{{- if or (len .Params) (len .Results) }}
	// call history
	recv.{{ $method.FieldName }}.History = append(recv.{{ $method.FieldName }}.History, struct {
	{{- if len .Params }}
		Params struct {
		{{- range .Params }}
			{{ .String }}
		{{- end }}
		}
	{{- end }}
	{{- if len .Results}}
		Results struct {
		{{- range .Results }}
			{{ .String }}
		{{- end }}
		}
	{{- end }}
	}{
	{{- if len .Params }}
		Params: recv.{{ $method.FieldName }}.Params,
	{{- end }}
	{{- if len .Results}}
		Results: recv.{{ $method.FieldName }}.Results,
	{{- end }}
	})
{{- end }}
{{- if len .Results}}
	// results
	return {{ range $idx, $val := .Results }}{{ if $idx }}, {{ end }}recv.{{ $method.FieldName }}.Results.{{ $val.Name }}{{ end }}
{{- end }}
}
{{ end -}}
{{ end }}`
)

var (
	tmpl = template.Must(template.New("").Parse(tmplString))
)

type mockInfo struct {
	Name           string
	HasConstructor bool
	Methods        []methodInfo
}

type methodInfo struct {
	Name      string
	FieldName string
	Params    []paramInfo
	Results   []resultInfo
}

func (m methodInfo) Signature() string {
	params := make([]string, 0, len(m.Params))
	for _, p := range m.Params {
		params = append(params, p.ParamString())
	}
	param := fmt.Sprintf("%s", strings.Join(params, ", "))

	results := make([]string, 0, len(m.Results))
	for _, r := range m.Results {
		results = append(results, r.ResultType())
	}
	result := strings.Join(results, ", ")
	if len(m.Results) > 1 {
		result = fmt.Sprintf("(%s)", result)
	}

	return fmt.Sprintf("%s(%s) %s", m.Name, param, result)
}

type paramInfo struct {
	name, paramName, typeString string
	isVariadic                  bool
}

func (p *paramInfo) Name() string {
	return p.name
}

func (p *paramInfo) ParamName() string {
	return p.paramName
}

func (p *paramInfo) ParamType() string {
	typeString := p.typeString
	if p.isVariadic {
		typeString = fmt.Sprintf("...%s", typeString[2:])
	}

	return fmt.Sprintf("%s", typeString)
}

func (p *paramInfo) ParamString() string {
	return fmt.Sprintf("%s %s", p.ParamName(), p.ParamType())
}

func (p *paramInfo) ArgString() string {
	var variadic string
	if p.isVariadic {
		variadic = "..."
	}

	return fmt.Sprintf("%s%s", p.paramName, variadic)
}

func (p *paramInfo) String() string {
	return fmt.Sprintf("%s %s", p.Name(), p.typeString)
}

type resultInfo struct {
	name, resultName, typeString string
}

func (r *resultInfo) Name() string {
	return r.name
}

func (r *resultInfo) ResultName() string {
	return r.resultName
}

func (r *resultInfo) ResultString() string {
	return fmt.Sprintf("%s %s", r.Name(), r.ResultType())
}

func (r *resultInfo) ResultType() string {
	return r.typeString
}

func (r *resultInfo) String() string {
	return fmt.Sprintf("%s %s", r.Name(), r.typeString)
}
