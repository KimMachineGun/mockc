// Code generated by Mockc. DO NOT EDIT.
// repo: https://github.com/KimMachineGun/mockc

//go:generate mockc
// +build !mockc

package basic

import "sync"

var _ interface {
	Cache
} = &MockcCache{}

type MockcCache struct {
	// method: Del
	DelFunc struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				P0 string
			}
			Results struct {
				R0 error
			}
		}
		// params
		Params struct {
			P0 string
		}
		// results
		Results struct {
			R0 error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string) error
	}
	// method: Get
	GetFunc struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				P0 string
			}
			Results struct {
				R0 interface{}
				R1 error
			}
		}
		// params
		Params struct {
			P0 string
		}
		// results
		Results struct {
			R0 interface{}
			R1 error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string) (interface{}, error)
	}
	// method: Set
	SetFunc struct {
		mu sync.Mutex
		// basics
		Called    bool
		CallCount int
		// call history
		History []struct {
			Params struct {
				P0 string
				P1 interface{}
			}
			Results struct {
				R0 error
			}
		}
		// params
		Params struct {
			P0 string
			P1 interface{}
		}
		// results
		Results struct {
			R0 error
		}
		// if it is not nil, it'll be called in the middle of the method.
		Body func(string, interface{}) error
	}
}

func (recv *MockcCache) Del(p0 string) error {
	recv.DelFunc.mu.Lock()
	defer recv.DelFunc.mu.Unlock()
	// basics
	recv.DelFunc.Called = true
	recv.DelFunc.CallCount++
	// params
	recv.DelFunc.Params.P0 = p0
	// body
	if recv.DelFunc.Body != nil {
		recv.DelFunc.Results.R0 = recv.DelFunc.Body(p0)
	}
	// call history
	recv.DelFunc.History = append(recv.DelFunc.History, struct {
		Params struct {
			P0 string
		}
		Results struct {
			R0 error
		}
	}{
		Params:  recv.DelFunc.Params,
		Results: recv.DelFunc.Results,
	})
	// results
	return recv.DelFunc.Results.R0
}

func (recv *MockcCache) Get(p0 string) (interface{}, error) {
	recv.GetFunc.mu.Lock()
	defer recv.GetFunc.mu.Unlock()
	// basics
	recv.GetFunc.Called = true
	recv.GetFunc.CallCount++
	// params
	recv.GetFunc.Params.P0 = p0
	// body
	if recv.GetFunc.Body != nil {
		recv.GetFunc.Results.R0, recv.GetFunc.Results.R1 = recv.GetFunc.Body(p0)
	}
	// call history
	recv.GetFunc.History = append(recv.GetFunc.History, struct {
		Params struct {
			P0 string
		}
		Results struct {
			R0 interface{}
			R1 error
		}
	}{
		Params:  recv.GetFunc.Params,
		Results: recv.GetFunc.Results,
	})
	// results
	return recv.GetFunc.Results.R0, recv.GetFunc.Results.R1
}

func (recv *MockcCache) Set(p0 string, p1 interface{}) error {
	recv.SetFunc.mu.Lock()
	defer recv.SetFunc.mu.Unlock()
	// basics
	recv.SetFunc.Called = true
	recv.SetFunc.CallCount++
	// params
	recv.SetFunc.Params.P0 = p0
	recv.SetFunc.Params.P1 = p1
	// body
	if recv.SetFunc.Body != nil {
		recv.SetFunc.Results.R0 = recv.SetFunc.Body(p0, p1)
	}
	// call history
	recv.SetFunc.History = append(recv.SetFunc.History, struct {
		Params struct {
			P0 string
			P1 interface{}
		}
		Results struct {
			R0 error
		}
	}{
		Params:  recv.SetFunc.Params,
		Results: recv.SetFunc.Results,
	})
	// results
	return recv.SetFunc.Results.R0
}
