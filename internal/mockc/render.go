package mockc

import (
	"bytes"
	"fmt"
	"go/types"
	"strings"

	"golang.org/x/tools/go/packages"

	"github.com/dave/jennifer/jen"
)

func render(pkg *packages.Package, mocks []mockInfo, gogenerate string) ([]byte, error) {
	f := jen.NewFilePathName(pkg.PkgPath, pkg.Name)

	f.PackageComment("// Code generated by Mockc. DO NOT EDIT.")
	f.PackageComment("// repo: https://github.com/KimMachineGun/mockc\n")
	f.PackageComment(fmt.Sprintf("//go:generate %s", gogenerate))
	f.PackageComment("// +build !mockc\n")

	for _, mock := range mocks {
		f.Var().Id("_").Do(func(s *jen.Statement) {
			typeCode(s, mock.typ)
		}).Op("=").Op("&").Id(mock.name).Values()
		f.Type().Id(mock.name).StructFunc(func(g *jen.Group) {
			for _, method := range mock.methods {
				g.Commentf("method: %s", method.typ.Name())
				g.Id(method.fieldName).StructFunc(func(g *jen.Group) {
					g.Id("mu").Qual("sync", "Mutex")
					g.Comment("basics")
					g.Id("Called").Bool()
					g.Id("CallCount").Int()
					if len(method.params)+len(method.results) > 0 {
						g.Comment("call history")
						g.Id("History").Index().StructFunc(func(g *jen.Group) {
							if len(method.params) > 0 {
								g.Id("Params").StructFunc(func(g *jen.Group) {
									for i, param := range method.params {
										param := param
										g.Do(func(s *jen.Statement) {
											typeCode(s.Id(fmt.Sprintf("P%d", i)), param.typ.Type())
										})
									}
								})
							}
							if len(method.results) > 0 {
								g.Id("Results").StructFunc(func(g *jen.Group) {
									for i, result := range method.results {
										result := result
										g.Do(func(s *jen.Statement) {
											typeCode(s.Id(fmt.Sprintf("R%d", i)), result.typ.Type())
										})
									}
								})
							}
						})
					}
					if len(method.params) > 0 {
						g.Comment("params")
						g.Id("Params").StructFunc(func(g *jen.Group) {
							for i, param := range method.params {
								param := param
								g.Do(func(s *jen.Statement) {
									typeCode(s.Id(fmt.Sprintf("P%d", i)), param.typ.Type())
								})
							}
						})
					}
					if len(method.results) > 0 {
						g.Comment("results")
						g.Id("Results").StructFunc(func(g *jen.Group) {
							for i, result := range method.results {
								result := result
								g.Do(func(s *jen.Statement) {
									typeCode(s.Id(fmt.Sprintf("R%d", i)), result.typ.Type())
								})
							}
						})
					}
					g.Comment("if it is not nil, it'll be called in the middle of the method.")
					g.Id("Body").Do(func(s *jen.Statement) {
						typeCode(s, method.typ.Type())
					})
				})
			}
		})

		if mock.constructor != "" {
			f.Func().Id(mock.constructor).Params(
				jen.Id("v").Op("...").Do(func(s *jen.Statement) {
					typeCode(s, mock.typ)
				}),
			).Op("*").Id(mock.name).Block(
				jen.Id("m").Op(":=").Op("&").Id(mock.name).Values(),
				jen.If(jen.Len(jen.Id("v")).Op(">").Lit(0)).BlockFunc(func(g *jen.Group) {
					for _, method := range mock.methods {
						g.Id("m").Dot(method.fieldName).Dot("Body").Op("=").Id("v").Index(jen.Lit(0)).Dot(method.typ.Name())
					}
				}),
				jen.Return(jen.Id("m")),
			).Line()
		}

		for _, method := range mock.methods {
			f.Func().Params(jen.Id("recv").Op("*").Id(mock.name)).Id(method.typ.Name()).ParamsFunc(func(g *jen.Group) {
				for i, param := range method.params {
					param := param
					g.Do(func(s *jen.Statement) {
						s.Id(fmt.Sprintf("p%d", i))
						if param.isVariadic {
							typeCode(s.Op("..."), param.typ.Type().(*types.Slice).Elem())
						} else {
							typeCode(s, param.typ.Type())
						}
					})
				}
			}).ParamsFunc(func(g *jen.Group) {
				for _, result := range method.results {
					result := result
					g.Do(func(s *jen.Statement) {
						typeCode(s, result.typ.Type())
					})
				}
			}).BlockFunc(func(g *jen.Group) {
				fieldName := jen.Id("recv").Dot(method.fieldName)

				g.Add(fieldName).Dot("mu").Dot("Lock").Call()
				g.Defer().Add(fieldName).Dot("mu").Dot("Unlock").Call()

				g.Comment("basics")
				g.Add(fieldName).Dot("Called").Op("=").True()
				g.Add(fieldName).Dot("CallCount").Op("++")

				if len(method.params) > 0 {
					g.Comment("params")
					for i := range method.params {
						g.Add(fieldName).Dot("Params").Dot(fmt.Sprintf("P%d", i)).Op("=").Id(fmt.Sprintf("p%d", i))
					}
				}

				g.Comment("body")
				g.If(jen.Add(fieldName).Dot("Body").Op("!=").Nil()).BlockFunc(func(g *jen.Group) {
					g.Do(func(s *jen.Statement) {
						if len(method.results) > 0 {
							s.ListFunc(func(g *jen.Group) {
								for i := range method.results {
									g.Add(fieldName).Dot("Results").Dot(fmt.Sprintf("R%d", i))
								}
							}).Op("=")
						}
						s.Add(fieldName).Dot("Body").CallFunc(func(g *jen.Group) {
							for i, param := range method.params {
								g.Do(func(s *jen.Statement) {
									s.Id(fmt.Sprintf("p%d", i))
									if param.isVariadic {
										s.Op("...")
									}
								})
							}
						})
					})
				})

				if len(method.params)+len(method.results) > 0 {
					g.Comment("call history")
					g.Id("recv").Dot(method.fieldName).Dot("History").Op("=").Append(
						jen.Id("recv").Dot(method.fieldName).Dot("History"),
						jen.StructFunc(func(g *jen.Group) {
							if len(method.params) > 0 {
								g.Id("Params").StructFunc(func(g *jen.Group) {
									for i, param := range method.params {
										param := param
										g.Do(func(s *jen.Statement) {
											typeCode(s.Id(fmt.Sprintf("P%d", i)), param.typ.Type())
										})
									}
								})
							}
							if len(method.results) > 0 {
								g.Id("Results").StructFunc(func(g *jen.Group) {
									for i, result := range method.results {
										result := result
										g.Do(func(s *jen.Statement) {
											typeCode(s.Id(fmt.Sprintf("R%d", i)), result.typ.Type())
										})
									}
								})
							}
						}).Values(jen.DictFunc(func(d jen.Dict) {
							if len(method.params) > 0 {
								d[jen.Id("Params")] = jen.Add(fieldName).Dot("Params")
							}
							if len(method.results) > 0 {
								d[jen.Id("Results")] = jen.Add(fieldName).Dot("Results")
							}
						})),
					)
				}

				if len(method.results) > 0 {
					g.Comment("results")
					g.ReturnFunc(func(g *jen.Group) {
						for i := range method.results {
							g.Add(fieldName).Dot("Results").Dot(fmt.Sprintf("R%d", i))
						}
					})
				}
			}).Line()
		}
	}

	b := bytes.NewBuffer(nil)
	err := f.Render(b)
	if err != nil {
		return nil, err
	}

	return b.Bytes(), nil
}

func typeCode(stmt *jen.Statement, t types.Type) jen.Code {
	switch t := t.(type) {
	case *types.Basic:
		switch t.Name() {
		case "bool":
			return stmt.Bool()
		case "int":
			return stmt.Int()
		case "int8":
			return stmt.Int8()
		case "int16":
			return stmt.Int16()
		case "int32":
			return stmt.Int32()
		case "int64":
			return stmt.Int64()
		case "uint":
			return stmt.Uint()
		case "uint8":
			return stmt.Uint8()
		case "uint16":
			return stmt.Uint16()
		case "uint32":
			return stmt.Uint32()
		case "uint64":
			return stmt.Uint64()
		case "uintptr":
			return stmt.Uintptr()
		case "float32":
			return stmt.Float32()
		case "float64":
			return stmt.Float64()
		case "complex64":
			return stmt.Complex64()
		case "complex128":
			return stmt.Complex128()
		case "string":
			return stmt.String()
		case "Pointer":
			return stmt.Qual("unsafe", "Pointer")
		case "byte":
			return stmt.Byte()
		case "rune":
			return stmt.Rune()
		}
	case *types.Array:
		return typeCode(stmt.Index(jen.Lit(t.Len())), t.Elem())
	case *types.Slice:
		return typeCode(stmt.Index(), t.Elem())
	case *types.Struct:
		return stmt.StructFunc(func(g *jen.Group) {
			for i := 0; i < t.NumFields(); i++ {
				f := t.Field(i)
				g.Do(func(s *jen.Statement) {
					if f.Anonymous() {
						typeCode(s, f.Type())
					} else {
						typeCode(s.Id(f.Name()), f.Type())
					}
				})
			}
		})
	case *types.Pointer:
		return typeCode(stmt.Op("*"), t.Elem())
	case *types.Tuple:
		return stmt.ValuesFunc(func(g *jen.Group) {
			typeTupleCode(g, t, false)
		})
	case *types.Signature:
		return stmt.Func().ParamsFunc(func(g *jen.Group) {
			typeTupleCode(g, t.Params(), t.Variadic())
		}).ParamsFunc(func(g *jen.Group) {
			typeTupleCode(g, t.Results(), false)
		})
	case *types.Interface:
		return stmt.InterfaceFunc(func(g *jen.Group) {
			for i := 0; i < t.NumEmbeddeds(); i++ {
				e := t.EmbeddedType(i)
				g.Do(func(s *jen.Statement) {
					typeCode(s, e)
				})
			}
			for i := 0; i < t.NumExplicitMethods(); i++ {
				m := t.ExplicitMethod(i)
				sig := m.Type().(*types.Signature)

				g.Do(func(s *jen.Statement) {
					s.Id(m.Name()).ParamsFunc(func(g *jen.Group) {
						typeTupleCode(g, sig.Params(), sig.Variadic())
					}).ParamsFunc(func(g *jen.Group) {
						typeTupleCode(g, sig.Results(), false)
					})
				})
			}
		})
	case *types.Map:
		return typeCode(stmt.Map(typeCode(nil, t.Key())), t.Elem())
	case *types.Chan:
		switch t.Dir() {
		case types.SendRecv:
			return typeCode(stmt.Chan(), t.Elem())
		case types.RecvOnly:
			return typeCode(stmt.Op("<-").Chan(), t.Elem())
		default:
			return typeCode(stmt.Chan().Op("<-"), t.Elem())
		}
	case *types.Named:
		if i := strings.LastIndex(t.String(), "."); i >= 0 {
			return stmt.Qual(t.String()[:i], t.String()[i+1:])
		}
		return stmt.Id(t.String())
	}
	return stmt
}

func typeTupleCode(g *jen.Group, t *types.Tuple, variadic bool) {
	for i := 0; i < t.Len(); i++ {
		g.Do(func(s *jen.Statement) {
			v := t.At(i)
			if variadic && i+1 == t.Len() {
				typeCode(s.Id("").Op("..."), v.Type().(*types.Slice).Elem())
			} else {
				typeCode(s.Id(""), v.Type())
			}
		})
	}
}

type mockInfo struct {
	typ         *types.Interface
	name        string
	constructor string
	methods     []methodInfo
}

type methodInfo struct {
	typ       *types.Func
	fieldName string
	params    []paramInfo
	results   []resultInfo
}

type paramInfo struct {
	typ        *types.Var
	isVariadic bool
}

type resultInfo struct {
	typ *types.Var
}
